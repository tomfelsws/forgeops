# Stages represented in Gitlab
stages:
  - build-base-images
  - build-forgeops-images
  - deploy-review
  - cleanup-review
  - deploy-test
  - run-test
  - cleanup-test
  - deploy-staging
  - cleanup-staging
  - deploy-production
  - cleanup-production

# Some defined variables
variables:
  # OpenShift/Kubernetes cluster URL
  # define/override in the various deploy-xxx jobs below for different clusters
  KUBERNETES_SERVER: console.appuio.ch

  # Domain of OpenShift/Kubernetes apps
  # define/override in the various deploy-xxx jobs below for different DNS domains per cluster
  DOMAIN: appuioapp.ch

  # OpenShift project (aka Kubernetes namespace) to deploy in
  # Use name of branch - assumes namespace exists or can be created
  # To create a namespace, the gitlab service account requires Kubernetes cluster-admin privileges
  # Define value in deploy jobs below
  # NAMESPACE variable used in deploy-lib.sh
  # define/override in the various deploy-xxx jobs below where necessary
  NAMESPACE: sws-$CI_COMMIT_REF_SLUG

  # Configure this variable in Secure Variables:
  #KUBERNETES_TOKEN: xxx

  # OpenShift client (oc) version of appui/oc docker image used in openshift_login stub below
  # For different clusters with different versions this variable must be separated (e.g. OPENSHIFT_VERSION_TEST: 3.11)
  OPENSHIFT_VERSION: "3.9"

  # Kubernetes client (kubectl) version to install in deploy-lib.sh/setup_kubectl()
  KUBERNETES_VERSION: "1.10.9"

  # Helm client version to install in deploy-lib.sh/setup_helm()
  HELM_VERSION: "2.12.1"

  # Helm tiller namespace used in deploy-lib.sh/setup_helm()
  TILLER_NAMESPACE: sws-tiller

  # Helm repo with Forgerock helm charts
  # Will be iuploaded there by push-helm-charts job below
  HELM_REPO_URL: https://chartmuseum-sws-chartmuseum.$DOMAIN
  HELM_REPO_USERNAME: appuio

  # Forgerock Platform version
  VERSION: 6.5.0

  # Where is GitLab stuff (e.g. serviceaccount 'gitlab')?
  GITLAB_NAMESPACE: sws-gitlab

  # ForgeOps config folder with helm yaml files (under ./config/$FORGEOPS_CONFIG)
  # define/override in the various deploy-xxx jobs below for different environments (dev, test, stag, prod)
  FORGEOPS_COMMON: swissid-common
  FORGEOPS_CONFIG: swissid-common

  # The Forgerock components to deploy
  # Note: The ds stores are aliased as configstore, userstore, ctstore - but they all use the ds chart
  COMPONENTS: "frconfig configstore userstore ctsstore openam amster"

  # Configstore settings
  # define/override in the various deploy-xxx jobs below for different environments (dev, test, stag, prod)
  CONFIGSTORE_REPLICAS: 1
  CONFIGSTORE_AFFINITY: soft

  # Tokenstore settings
  # define/override in the various deploy-xxx jobs below for different environments (dev, test, stag, prod)
  CTS_REPLICAS: 1
  CTS_AFFINITY: soft

  # Configstore settings
  # define/override in the various deploy-xxx jobs below for different environments (dev, test, stag, prod)
  USERSTORE_REPLICAS: 1
  USERSTORE_AFFINITY: soft

  # OpenAM settings
  # define/override in the various deploy-xxx jobs below for different environments (dev, test, stag, prod)
  OPENAM_REPLICAS: 1

  # Remove all deployments/configmaps/secrets/pvcs from namespace before every deployment?
  # define/override to "no" in staging & production deployment jobs, as we must upgrade there
  RMALL: "yes"


# Stub to build docker images
.build-docker-image: &build-docker-image
  image: docker:stable
  services:
    - docker:stable-dind
  script:
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
    - docker build --build-arg API_KEY=$API_KEY --pull -t "$CI_REGISTRY_IMAGE/$IMAGE:$CI_COMMIT_SHA" docker/$IMAGE
    - docker tag  "$CI_REGISTRY_IMAGE/$IMAGE:$CI_COMMIT_SHA" "$CI_REGISTRY_IMAGE/$IMAGE:$VERSION"
    - docker tag  "$CI_REGISTRY_IMAGE/$IMAGE:$CI_COMMIT_SHA" "$CI_REGISTRY_IMAGE/$IMAGE:latest"
    - docker push "$CI_REGISTRY_IMAGE/$IMAGE"

build-downloader-docker-image:
  <<: *build-docker-image
  stage: build-base-images
  variables:
    IMAGE: downloader
  only:
    refs:
      - swissid
    changes:
      - docker/downloader/**/*

build-git-docker-image:
  <<: *build-docker-image
  stage: build-base-images
  variables:
    IMAGE: git
  only:
    refs:
      - swissid
    changes:
      - docker/git/**/*

build-java-docker-image:
  <<: *build-docker-image
  stage: build-base-images
  variables:
    IMAGE: java
  only:
    refs:
      - swissid
    changes:
      - docker/java/**/*

build-util-docker-image:
  <<: *build-docker-image
  stage: build-base-images
  variables:
    IMAGE: util
  only:
    refs:
      - swissid
    changes:
      - docker/util/**/*

build-amster-docker-image:
  <<: *build-docker-image
  stage: build-forgeops-images
  variables:
    IMAGE: amster
  only:
    refs:
      - swissid
    changes:
      - docker/downloader/**/*
      - docker/java/**/*
      - docker/amster/**/*

build-openam-docker-image:
  <<: *build-docker-image
  stage: build-forgeops-images
  variables:
    IMAGE: openam
  only:
    refs:
      - swissid
    changes:
      - docker/downloader/**/*
      - docker/openam/**/*

build-ds-docker-image:
  <<: *build-docker-image
  stage: build-forgeops-images
  variables:
    IMAGE: ds
  only:
    refs:
      - swissid
    changes:
      - docker/downloader/**/*
      - docker/ds/**/*

#build-apache-agent-docker-image:
#  <<: *build-docker-image
#  stage: build-forgeops-images
#  variables:
#    IMAGE: apache-agent
#  only:
#    refs:
#      - swissid
#    changes:
#      - docker/downloader/**/*
#      - docker/apache-agent/**/*

#build-nginx-agent-docker-image:
#  <<: *build-docker-image
#  stage: build-forgeops-images
#  variables:
#    IMAGE: apache-agent
#  only:
#    resf:
#      - swissid
#    changes:
#      - docker/downloader/**/*
#      - docker/nginx-agent/**/*

push-helm-charts:
  image: docker.io/appuio/helm:v2.12.0
  stage: build-base-images
  script:
    - for CHART in $(find helm/ -maxdepth 1 -mindepth 1 -type d); do
        helm push $CHART $HELM_REPO_URL ;
      done
  only:
    refs:
      - swissid
    changes:
      - helm/**/*

# Trigger deploy-config project
.trigger-deploy:
  image: $CI_REGISTRY_IMAGE/util:$VERSION
  stage: trigger-deploy
  script:
    - curl -X POST -F token=$3e8b6155b64da122a1c458ce02d6e2 -F ref=test-ci https://gitlab.com/api/v4/projects/9979791/trigger/pipeline
  only:
    refs:
      - swissid
    changes:
      - docker/**/*
      - helm/**/*
      - .gitlab-ci.yml

# Test 1
test1:
  stage: run-test
  script:
    - echo "Run Test Suite 1"
  only:
    refs:
      - swissid

# Test 2
test2:
  stage: run-test
  script:
    - echo "Run Test Suite 2"
  only:
    refs:
      - swissid

# Stub to connect to Kubernetes cluster
.openshift_login: &openshift_login
  # image: ayufan/openshift-cli
  # image: dtzar/helm-kubectl:$HELM_VERSION
  image: appuio/oc:v$OPENSHIFT_VERSION
  before_script:
    - echo "Login to $KUBERNETES_SERVER"
    ### Obtain service account token as follows, then add it to the GitLab CI/CD variables
    # oc project $GITLAB_NAMESPACE
    # KUBERNETES_TOKEN=$( oc serviceaccounts get-token gitlab )
    ### Add gitlab service account edit rights to $NAMESPACE.
    ### This must be done manually, after $NAMESPACE is created.
    ### Otherwise the "oc project" below will not work (as the gitlab service account has no rights in that namespace)
    # oc -n $NAMESPACE policy add-role-to-user admin system:serviceaccount:$GITLAB_NAMESPACE:gitlab
    - oc login "$KUBERNETES_SERVER" --token="$KUBERNETES_TOKEN"

# Stub to deploy to Kubernetes cluster
.deploy: &deploy
  script:
    # next line should be included in the docker image we use (currently appuio/oc)
    - yum install -y gettext
    - source bin/deploy-lib.sh
    - delete_project
    - create_project
    - oc project "$NAMESPACE"
    - setup_kubectl
    - setup_helm
    - chk_config
    #- remove_all
    - create_image_pull_secret
    - deploy_charts
    - import_check
    - restart_am
    - scale_am

# Stub to cleanup from Kubernetes cluster
.cleanup: &cleanup
  script:
    - delete_project
    # next line should be included in the docker image we use (currently appuio/oc)
    #- yum install -y gettext
    #- source bin/deploy-lib.sh
    #- setup_kubectl
    #- setup_helm
    #- chk_config
    #- remove_all

# Deploy to review environment
deploy-review:
  <<: *openshift_login
  stage: deploy-review
  environment:
    name: review/$CI_COMMIT_REF_NAME
    url: http://login.$CI_COMMIT_REF_SLUG.$DOMAIN
    on_stop: cleanup-review
  variables:
    EXTERNAL_FQDN: login.$CI_COMMIT_REF_SLUG.$DOMAIN
  <<: *deploy
  only:
    - branches
  except:
    - master
    - swissid

# Delete from review environment
cleanup-review:
  <<: *openshift_login
  stage: cleanup-review
  when: manual
  environment:
    name: review/$CI_COMMIT_REF_NAME
    action: stop
  variables:
    # Setting the GIT_STRATEGY to none is necessary on the stop_review job so that the GitLab Runner won’t try to checkout the code after the branch is deleted.
    # we need the git repo for the script above
    # GIT_STRATEGY: none
  <<: *cleanup
  only:
    - branches
  except:
    - master
    - swissid

# Deploy to test environment
deploy-test:
  <<: *openshift_login
  stage: deploy-test
  environment:
    name: test
    url: http://login.test.$DOMAIN
    on_stop: cleanup-test
  variables:
    EXTERNAL_FQDN: login.test.$DOMAIN
    NAMESPACE: sws-test
    CONFIGSTORE_REPLICAS: 2
    CONFIGSTORE_AFFINITY: soft
    CTS_REPLICAS: 2
    CTS_AFFINITY: soft
    USERSTORE_REPLICAS: 2
    USERSTORE_AFFINITY: soft
    OPENAM_REPLICAS: 2
  <<: *deploy
  only:
    - swissid

# Delete from test environment
cleanup-test:
  <<: *openshift_login
  stage: cleanup-test
  when: manual
  environment:
    name: test
    action: stop
  variables:
    # Setting the GIT_STRATEGY to none is necessary on the stop_review job so that the GitLab Runner won’t try to checkout the code after the branch is deleted.
    # we need the git repo for the script above
    # GIT_STRATEGY: none
    NAMESPACE: sws-test
  <<: *cleanup
  only:
    - swissid

# Deploy to staging environment
deploy-staging:
  <<: *openshift_login
  stage: deploy-staging
  when: manual
  environment:
    name: staging
    url: http://login.stag.$DOMAIN
    on_stop: cleanup-staging
  variables:
    EXTERNAL_FQDN: login.stag.$DOMAIN
    NAMESPACE: sws-staging
    CONFIGSTORE_REPLICAS: 2
    CONFIGSTORE_AFFINITY: hard
    CTS_REPLICAS: 2
    CTS_AFFINITY: hard
    USERSTORE_REPLICAS: 2
    USERSTORE_AFFINITY: hard
    OPENAM_REPLICAS: 2
  <<: *deploy
  only:
    - swissid

# Delete from staging environment
cleanup-staging:
  <<: *openshift_login
  stage: cleanup-staging
  when: manual
  environment:
    name: staging
    action: stop
  variables:
    # Setting the GIT_STRATEGY to none is necessary on the stop_review job so that the GitLab Runner won’t try to checkout the code after the branch is deleted.
    # we need the git repo for the script above
    # GIT_STRATEGY: none
    NAMESPACE: sws-staging
  <<: *cleanup
  only:
    - swissid

# Deploy to production environment
deploy-production:
  <<: *openshift_login
  stage: deploy-production
  when: manual
  environment:
    name: production
    url: http://login.$DOMAIN
    on_stop: cleanup-production
  variables:
    EXTERNAL_FQDN: login.$DOMAIN
    NAMESPACE: sws-production
    CONFIGSTORE_REPLICAS: 2
    CONFIGSTORE_AFFINITY: hard
    CTS_REPLICAS: 2
    CTS_AFFINITY: hard
    USERSTORE_REPLICAS: 2
    USERSTORE_AFFINITY: hard
    OPENAM_REPLICAS: 2
  <<: *deploy
  only:
    - swissid

# Delete from production environment
cleanup-production:
  <<: *openshift_login
  stage: cleanup-production
  when: manual
  environment:
    name: production
    action: stop
  variables:
    # Setting the GIT_STRATEGY to none is necessary on the stop_review job so that the GitLab Runner won’t try to checkout the code after the branch is deleted.
    # we need the git repo for the script above
    # GIT_STRATEGY: none
    NAMESPACE: sws-production
  <<: *cleanup
  only:
    - swissid
